/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from 'ethers';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';
import type { TypedEventFilter, TypedEvent, TypedListener } from './common';

interface BaseAtlanticPoolInterface extends ethers.utils.Interface {
  functions: {
    'getCumulativeLiquidityForStrike(uint256,uint256)': FunctionFragment;
    'getNextNode(uint256)': FunctionFragment;
    'getNode(uint256)': FunctionFragment;
    'getPreviousNode(uint256)': FunctionFragment;
    'getSortedSpot(address,uint256)': FunctionFragment;
    'getValue(uint256)': FunctionFragment;
    'insertAfter(uint256,uint256)': FunctionFragment;
    'insertBefore(uint256,uint256)': FunctionFragment;
    'listExists()': FunctionFragment;
    'nodeExists(uint256)': FunctionFragment;
    'popBack()': FunctionFragment;
    'popFront()': FunctionFragment;
    'pushBack(uint256)': FunctionFragment;
    'pushFront(uint256)': FunctionFragment;
    'remove(uint256)': FunctionFragment;
    'sizeOf()': FunctionFragment;
    'strikes(uint256)': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'getCumulativeLiquidityForStrike',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getNextNode',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getNode',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getPreviousNode',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getSortedSpot',
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'getValue',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'insertAfter',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'insertBefore',
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'listExists',
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: 'nodeExists',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'popBack', values?: undefined): string;
  encodeFunctionData(functionFragment: 'popFront', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'pushBack',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'pushFront',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: 'remove',
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: 'sizeOf', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'strikes',
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: 'getCumulativeLiquidityForStrike',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getNextNode',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'getNode', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getPreviousNode',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getSortedSpot',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'getValue', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'insertAfter',
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: 'insertBefore',
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: 'listExists', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nodeExists', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'popBack', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'popFront', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pushBack', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pushFront', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'remove', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'sizeOf', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'strikes', data: BytesLike): Result;

  events: {
    'LogNotice(bool)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'LogNotice'): EventFragment;
}

export type LogNoticeEvent = TypedEvent<[boolean] & { booleanValue: boolean }>;

export class BaseAtlanticPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: BaseAtlanticPoolInterface;

  functions: {
    getCumulativeLiquidityForStrike(
      startingIndex: BigNumberish,
      strike: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { cumulativeLiquidity: BigNumber }>;

    getNextNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber, BigNumber]>;

    getPreviousNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getSortedSpot(
      _structure: string,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getValue(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    insertAfter(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    insertBefore(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    listExists(overrides?: CallOverrides): Promise<[boolean]>;

    nodeExists(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    popBack(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    popFront(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    pushBack(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    pushFront(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    remove(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sizeOf(overrides?: CallOverrides): Promise<[BigNumber]>;

    strikes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        strike: BigNumber;
        liquidity: BigNumber;
        cumulativeLiquidity: BigNumber;
        putsWritten: BigNumber;
        premiumCollected: BigNumber;
        fundingCollected: BigNumber;
        activeCollateral: BigNumber;
      }
    >;
  };

  getCumulativeLiquidityForStrike(
    startingIndex: BigNumberish,
    strike: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNextNode(
    _node: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber]>;

  getNode(
    _node: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber, BigNumber]>;

  getPreviousNode(
    _node: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[boolean, BigNumber]>;

  getSortedSpot(
    _structure: string,
    _value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getValue(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  insertAfter(
    _node: BigNumberish,
    _new: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  insertBefore(
    _node: BigNumberish,
    _new: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  listExists(overrides?: CallOverrides): Promise<boolean>;

  nodeExists(_node: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

  popBack(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  popFront(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  pushBack(
    _node: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  pushFront(
    _node: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  remove(
    _node: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sizeOf(overrides?: CallOverrides): Promise<BigNumber>;

  strikes(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      strike: BigNumber;
      liquidity: BigNumber;
      cumulativeLiquidity: BigNumber;
      putsWritten: BigNumber;
      premiumCollected: BigNumber;
      fundingCollected: BigNumber;
      activeCollateral: BigNumber;
    }
  >;

  callStatic: {
    getCumulativeLiquidityForStrike(
      startingIndex: BigNumberish,
      strike: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber, BigNumber]>;

    getPreviousNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean, BigNumber]>;

    getSortedSpot(
      _structure: string,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValue(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    insertAfter(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    insertBefore(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    listExists(overrides?: CallOverrides): Promise<boolean>;

    nodeExists(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    popBack(overrides?: CallOverrides): Promise<void>;

    popFront(overrides?: CallOverrides): Promise<void>;

    pushBack(_node: BigNumberish, overrides?: CallOverrides): Promise<void>;

    pushFront(_node: BigNumberish, overrides?: CallOverrides): Promise<void>;

    remove(_node: BigNumberish, overrides?: CallOverrides): Promise<void>;

    sizeOf(overrides?: CallOverrides): Promise<BigNumber>;

    strikes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        strike: BigNumber;
        liquidity: BigNumber;
        cumulativeLiquidity: BigNumber;
        putsWritten: BigNumber;
        premiumCollected: BigNumber;
        fundingCollected: BigNumber;
        activeCollateral: BigNumber;
      }
    >;
  };

  filters: {
    'LogNotice(bool)'(
      booleanValue?: null
    ): TypedEventFilter<[boolean], { booleanValue: boolean }>;

    LogNotice(
      booleanValue?: null
    ): TypedEventFilter<[boolean], { booleanValue: boolean }>;
  };

  estimateGas: {
    getCumulativeLiquidityForStrike(
      startingIndex: BigNumberish,
      strike: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNextNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNode(_node: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    getPreviousNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSortedSpot(
      _structure: string,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValue(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    insertAfter(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    insertBefore(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    listExists(overrides?: CallOverrides): Promise<BigNumber>;

    nodeExists(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    popBack(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    popFront(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    pushBack(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    pushFront(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    remove(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sizeOf(overrides?: CallOverrides): Promise<BigNumber>;

    strikes(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    getCumulativeLiquidityForStrike(
      startingIndex: BigNumberish,
      strike: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNextNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPreviousNode(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSortedSpot(
      _structure: string,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValue(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    insertAfter(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    insertBefore(
      _node: BigNumberish,
      _new: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    listExists(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nodeExists(
      _node: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    popBack(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    popFront(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    pushBack(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    pushFront(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    remove(
      _node: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sizeOf(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    strikes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
